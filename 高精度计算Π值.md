# 高精度计算圆周率

## 描述
~~~~~
限制使用双向链表作存储结构，请根据用户输入的一个整数
该整数表示精确到小数点后的位数，可能要求精确到小数点后500位
高精度计算PI值。可以利用反三角函数幂级展开式来进行计算
~~~~~
-------
## Input
```正整数n```
## Output
```输出PI的值，精确到小数点后n位再输出回车符```
~~~~~
使用双向链表作为储存结构
提示用反三角函数的幂级展开式来进行计算
则取x=12x=12 arcsinx=π6arcsinx=π6.
π6=∑mnRnπ6=∑nmRn, Rn+1=(2n−1)22n(2n+1)RnRn+1=(2n−1)22n(2n+1)Rn.
利用该式求出展开式中各项的值，便能算出要求精度的π值。
具体实现：一个节点保存一位数。主要的操作有加、乘、除
~~~~~
```c
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;

struct Node{
    char elem;
    Node *nex, *pre;
    Node(int elem = 0, Node *nex = 0, Node *pre = 0):elem(elem), nex(nex), pre(pre){}
};
typedef Node *LinkList;

struct BigDec{
    LinkList Head;
    //int dot;  dot=1
    BigDec(int n = 500){
        int i = n;
        LinkList L,s;
        L = this->Head = new Node();
        L->nex = L->pre = L;
        while(i--){
            s = new Node(0, L->nex, L);
            L->nex->pre = s;
            L->nex = s;
        }
    }

    BigDec operator * (const long long rsh){
        LinkList pa= this->Head->pre;
        long long s = 0;
        while(pa != this->Head){
            long long x = rsh*(pa->elem);
            pa->elem = (x+s)%10;
            s = (x+s)/10;
            pa = pa->pre;
        }
        this->Head->elem += s;
        return *this;
    }

    BigDec operator / (const long long rsh){
        LinkList pa = this->Head->nex;
        long long s = this->Head->elem;
        if(s<rsh) {this->Head->elem = 0;s = (s%rsh)*10;}
        else {this->Head->elem = s/rsh; s = (s%rsh)*10;}
        while(pa != this->Head){
            s += pa->elem;
            if(s < rsh ){ pa->elem = 0;s = (s%rsh)*10;pa = pa->nex;}
            else {pa->elem = s/rsh;s = (s%rsh)*10; pa = pa->nex;}
        }
        return *this;
    }


    BigDec operator + (const BigDec &rsh){
        LinkList pa,pb;
        pa = this->Head->pre;
        pb = rsh.Head->pre;
        int s = 0;
        while(pa!=this->Head){
            int x = (pa->elem + pb->elem);
            pa->elem = (x+s)%10;
            s = (x+s)/10;
            pa = pa->pre;pb = pb->pre;
        }
        return *this;
    }

};

typedef BigDec *LBigDec;

void BigDec_pri(BigDec &BDec, int n){//打印
    LinkList p = BDec.Head->nex;
    printf("%d.", BDec.Head->elem);
    while(n--){
        printf("%d", p->elem);
        p = p->nex;
    }
    printf("\n");
}

int main(){
    int N;
    scanf("%d", &N);
    BigDec *a = new BigDec(N+10);
    BigDec *b = new BigDec(N+10);
    a->Head->nex->elem = 5;
    *b+*a;
    long long x, y;
    for(int i = 1; i<=N*10; i++){
        x = (long long)(2*i-1)*(2*i-1);
        y = (long long)(2*i)*(2*i+1)*4;
        (*a)*x;
        (*a)/y;
        //BigDec_pri(*a);
        (*b)+(*a);
    }
    (*b)*(long long)6;
    BigDec_pri(*b,N);

}
```
-----
## 解法二
```c
#include<stdio.h>
#include<stdlib.h>
int k;
typedef struct node {
	int data;
	struct node*next;
	struct node*pre;
}node,*list;
void init(list l)
{
    list tail = l, p;
	p=(list)malloc(sizeof(node));
	tail->next = p;
	p->pre = tail;
	tail = p;
	p->data = 2;
	tail->next = NULL;
}
void destorylist(list l)
{
	list p=l->next;
	list q;
	while (p->next)
	{
		q = p->next;
		free(p);
		p = q;
	}           //将头结点后逐项释放
	free(l);   //最后释放头结点
	l = NULL;
}
void insert(list l, int data)
{
	list p = l;
	if(p == NULL)
	{
		return;
	}
	else
	{
		while (p->next)
			p = p->next;
		list temp = (list)malloc(sizeof(node));
		p->next = temp;
		temp->data = data;
		temp->pre = p;
		temp->next = NULL;
	}
}
void traverse(list l)
{
	printf("%d.",l->next->data);
	l=l->next;
	list p;
	p=l->next;
	while(p!=NULL&&k)
	{
		printf("%d",p->data);
		p=p->next;
		k--;
	}
	printf("\n");
}
void SumAll(list p,list suml)
{
    list q,sum;
	int ret,tmp,cnt=3,num=1;
	int sign=1;
	while(sign)
	{
		q=p->next;
		sum=suml->next;
		ret=0;
		while(q->next)
		{
			q=q->next; //q指向p的最后一位
		}
		while (q)
		{
			tmp=q->data*num+ret;
			q->data=tmp%10;
			ret=tmp/10; //这个是进位
			if(q->pre==NULL)break;
			else
			{
				q=q->pre;
			}
		}   //乘法运算
		ret=0;
		q=p->next;
		while (q)
		{
			tmp=q->data+ret*10;
			q->data=tmp/cnt;
			ret=tmp%cnt;
			if(q->next==NULL)break;
			else
			{
				q=q->next;
			}
		}  // 除法运算
		q=p->next;
		sum=sum1->next;
		while(q->next&&sum->next)
		{
			q=q->next;
			sum=sum->next;
		}
		sign=0;
		while (q&&sum)
		{
            tmp=sum->data+q->data ;
			sum->data=tmp%10;
			if(sum->pre==NULL||q->pre==NULL)
			{
				break;
			}
			else
			{
				sum->pre->data+=tmp/10;
				sign |= q->data;
				sum=sum->pre;
				q=q->pre;
			}
		}
		num++;
		cnt+=2;
	}
}
int main()
{
	list p;
	list sum1;
	int i;
	scanf("%d",&k);
	p=(list)malloc(sizeof(node));
	sum1=(list)malloc(sizeof(node));
	p->next = NULL;
	sum1->next=NULL;
	p->pre = NULL;
	sum1->pre=NULL;
	init(p);
	init(sum1);
    for (i = 1; i <= 500; i++) {
        insert(p, 0);
        insert(sum1, 0);
    }
    SumAll(p, suml);
    traverse(sum1);
    destorylist(p);
    destorylist(sum1);
    return 0;
}
```
~~~~~
可使用泰勒展开式

~~~~~